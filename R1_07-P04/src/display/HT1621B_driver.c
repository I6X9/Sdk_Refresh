//≥Ã–Ú√˚£∫HT1621B_driver.C°£
//±‡–¥»À£∫¿Ó÷Œ«Â
//±‡–¥»’∆⁄£∫2015.09.30
//œµÕ≥æßÃÂ£∫96MHz
//MCU¿‡–Õ£∫M3
//Ω”ø⁄∂®“Â£∫HT_dat-1621µƒdata ˝æ›œﬂ£¨HT_wr-1621µƒ–¥ ±÷”Õ¨≤Ωœﬂ£¨HT_cs-1621µƒ πƒ‹/∏¥Œªœﬂ£¨
//          HT_rd-1621µƒ∂¡ ±÷”Õ¨≤Ωœﬂ°£
// π”√Àµ√˜£∫
//–ﬁ∏ƒ»’÷æ£∫
/*************************************************************************************/
//Õ∑Œƒº˛∞¸∫¨
#include "gpio.h"
#include "HT1621B_driver.h"
#include "app_config.h"
#include "seg_panel.h"
#include "dev_detect_driver.h"
#include "sys_app.h"
#include "task_decoder.h"
#include "bt_app_func.h"
#include "bt_control_api.h"
#include "sd_card.h"
#include "eq.h"
#include "eq_params.h"
#include "clk.h"
#include "fsinfo.h"
#include "sys_vol.h"
#include "sound_remind.h"
#include "mixer.h"
#include "breakpoint.h"
#include "recorder_control.h"
#include "nvm.h"
#include "browser.h"
#include "lrc.h"
#include "timer_api.h"
#include "string_convert.h"
#include "player_control.h"
#include "rtc_control.h"
#include "radio_control.h"

#ifdef    FUNC_HT1621_DISPLAY_EN
/***********************************************************************************/
//≥£”√øÿ÷∆√¸¡Ó
#define   SYS_dis    0x00   //πÿ±’œµÕ≥ ±÷”
#define   SYS_on     0x01   //ø™œµÕ≥ ±÷”
#define   LCD_off    0x02   //πÿ±’LCDœ‘ æ
#define   LCD_on     0x03   //ø™LCDœ‘ æ
#define   timer_dis  0x04   //πÿ±’ ±÷” ‰≥ˆ
#define   WDT_dis    0x05   //πÿ±’ø¥√≈π∑
#define   tone_off   0x08   //πÿ±’…˘“Ù ‰≥ˆ
#define   XTAL       0x18   //œµÕ≥æßÃÂ—°‘Ò
#define   BIAS       0x29   //∆´—πº∞’ºø’±»…Ë÷√

TIMER  ColDispTimer;
TIMER  PrevDispTimer;
TIMER  UpdataDispTimer;
DISP_MODULE_ID    CurDisplayId  =  DISP_MODULE_NONE;              //µ±«∞–Ë“™œ‘ æµƒƒ⁄»›
 //…œ“ª¥Œœ‘ æµƒƒ⁄»›£¨”√”⁄µ±ƒ≥∏ˆƒ⁄»›–Ë“™œ‘ æπÃ∂® ±º‰£¨‘⁄œ‘ æπ˝≥Ã÷–≤ªƒ‹À¢–¬µ±«∞œ‘ æƒ⁄»›µƒŒ Ã‚¨
static DISP_MODULE_ID    PrevDisplayId = DISP_MODULE_NONE;
static bool ColDispFlag;

static uint8_t const NumberTab [10] = {0xFD,0x0D,0xDB,0x9F,0x2F,0xBE,0xFE,0x1D,0xFF,0xBF};
//.......................................0.....1...2....3....4....5....6.....7....8....9.//
//Œ™¡À‘⁄À¢–¬œ‘ æ ˝æ› ±≤ª”∞œÏ∆‰À˚±Í÷æµƒœ‘ æ£¨À˘“‘Ω´ø’œ–BITŒ™1£¨‘⁄À¢–¬ ˝æ› ±”√°∞¬ﬂº≠”Î°±

uint8_t  DisplayBuffer [13] = {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x67,0x00,0x00,0x00,0x00,0x00}; 	

/*************************************************************************************/
#ifdef FUNC_HT1621_DISPLAY_EN
static __INLINE void HT1621DisplayDelay(void)
{
	__nop();
}
#endif
/*************************************************************************************/
static  void  Init_1621(void)
{
      HT1621_CS_SET();
	    HT1621_CLK_SET();
	    HT1621_DAT_SET();
	    HT1621DisplayDelay();
	    HT1621_CS_CLR();
	    HT1621_CS_CLR();
	    HT1621_CLK_CLR();
	    HT1621_CLK_CLR();
}
/*************************************************************************************/
static  void  Sendchar_h(uint8_t dat,uint8_t count)                 //datµƒcountŒª–¥»Î1621£¨∏ﬂŒª‘⁄«∞
{
      for (;count > 0;count--)
	    {
          if ((dat&0x80) == 0x00)
	           HT1621_DAT_CLR();
	        else
	           HT1621_DAT_SET();
	       HT1621_CLK_CLR();
	       HT1621DisplayDelay();
	       HT1621_CLK_SET();
	       dat <<= 1;
      }
}
/*************************************************************************************/
static  void  Sendchar_l(uint8_t dat,uint8_t count)                 //datµƒcountŒª–¥»Î1621£¨µÕŒª‘⁄«∞
{
      for (;count > 0;count--)
	    {
          if ((dat&0x01) == 0x00)
	           HT1621_DAT_CLR();
	        else
	           HT1621_DAT_SET();
	       HT1621_CLK_CLR();
	       HT1621DisplayDelay();
	       HT1621_CLK_SET();
	       dat >>= 1;
      }
}
/*************************************************************************************/
static  void  write_cmd(uint8_t command)                          //–¥1621øÿ÷∆√¸¡Ó
{   
      HT1621_CS_CLR();
	    Init_1621();
      Sendchar_h(0x80,3);
      Sendchar_h(command,9);
      HT1621_CS_SET();
}
/*************************************************************************************/
void  HT1621DisplayClr(void)    //«Â≥˝1621À˘”–œ‘ æ°¢«Â∆¡
{
	    uint8_t count = 0;
	    for(count = 0; count < 13; count++)
			{
				DisplayBuffer[count] = 0x00;
			}
}
/*************************************************************************************/
void  SendHt1621DispMsg(DISP_MODULE_ID  DispId)               //¥´ÀÕœ‘ æ√¸¡Ó
{
	    CurDisplayId = DispId;
}
/*************************************************************************************/
static void  DisplayModuleFlag(void)    //À¢–¬ƒ£ Ω∫Õ√Î±Í÷æ
{
	     //œ»«Â≥˝À˘”–ƒ£ ΩÕº±Í°£
	    DISP_MODEFLAG_OFF();
	    if(gSys.CurModuleID != MODULE_ID_RTC)
			//»Áπ˚≤ª «‘⁄RTCƒ£ Ω£¨Ω´√ÎÕº±Íπÿ±’°£
			{
				 DISP_COL_OFF();
			}
	    if(gSys.CurModuleID == MODULE_ID_PLAYER_USB)
				//œ‘ æUSBÕº±Í
			{
				 DISP_USB_ON();
			}
			else if(gSys.CurModuleID == MODULE_ID_PLAYER_SD)
			{
				 if((GetCurReadCard() == TFTOSD_CARD_TYPE) || \
					   (GetCurReadCard() == SD_CARD_TYPE))
				 //‘⁄SDø®ƒ£ Ω°£œ‘ æSDÕº±Í
				 {
					   DISP_SDCARD_ON();
				 }
				 else
					//‘⁄TFø®ƒ£ Ω£¨œ‘ æTFÕº±Í°£
				 {
					   DISP_TFCARD_ON();
				 }
			}
			else if (gSys.CurModuleID == MODULE_ID_RADIO)
			//œ‘ æFMÕº±Í
			{
				  DISP_FM_ON();
			}
}
/************************************************************************************/
static void DisplayWelcome(void)        //œ‘ æª∂”≠–≈œ¢
{
	    uint8_t  count = 0;
			HT1621_CS_CLR();
	    Init_1621();
      Sendchar_h(0xa0,3);
      Sendchar_h(0x18,6);
      for (count = 0;count < 13 ;count++)
	    {
			  if(count == 6)
				{
           Sendchar_l(0x05,8);
				}
				else if(count == 7)
				{
					 Sendchar_l(0x67,8);
				}
				else
				{
					 Sendchar_l(0x00,8);
				}
      }
      HT1621_CS_SET();
			TimeOutSet(&PrevDispTimer, 3000);
}
/************************************************************************************/
void  HT1621DisplayInit(void)                         //≥ı ºªØHT1621£¨≤¢œ‘ æª∂”≠–≈œ¢
{
      write_cmd(BIAS);                                        //LCD∆´—π…Ë÷√
      write_cmd(XTAL);                                      // ±÷”‘¥—°‘Ò
	    write_cmd(timer_dis);                               //πÿ±’ ±÷” ‰≥ˆ
	    write_cmd(WDT_dis);                                //πÿ±’ø¥√≈π∑
	    write_cmd(tone_off);                                  //πÿ±’…˘“Ù ‰≥ˆ
      write_cmd(SYS_on);                                  //ø™œµÕ≥ ±÷”
      HT1621DisplayDelay();                              //  µ±—” ±
	    TimeOutSet(&ColDispTimer, 0);
	    TimeOutSet(&PrevDispTimer, 0);           //∆Ù∂Øœ‘ æœ‡πÿ∂® ±∆˜
      write_cmd(LCD_on);                                  //ø™LCDœ‘ æ
	    DisplayWelcome();                                  //œ‘ æª∂”≠–≈œ¢
}
/************************************************************************************/
static void DisplayTimer(void)        //œ‘ æ≤•∑≈ ±º‰
{
	        DISP_COL_ON();                       //√Î∑˚∫≈≥£¡¡£¨±Ì æ’˝‘⁄≤•∑≈
	        DisplayBuffer[8] |= 0xF7;
				  DisplayBuffer[8] &= NumberTab[gPlayContrl->CurPlayTime / 1000 / 60 / 10];
				  DisplayBuffer[7] |= 0xF7;
	        DisplayBuffer[7] &= NumberTab[gPlayContrl->CurPlayTime/ 1000 / 60 % 10];
				  DisplayBuffer[6] |= 0xF7;
	        DisplayBuffer[6] &= NumberTab[gPlayContrl->CurPlayTime / 1000 % 60 / 10];
				  DisplayBuffer[5] |= 0xF7;
	        DisplayBuffer[5] &= NumberTab[gPlayContrl->CurPlayTime / 1000 % 60 % 10];
}
/************************************************************************************/
static void DispSongNumber(void)        //œ‘ æ∏Ë«˙«˙ƒø
{
	        DisplayBuffer[8] |= 0xF7;
					DisplayBuffer[8] &= NumberTab[gPlayContrl->CurFileIndex / 1000 ];
				  DisplayBuffer[7] |= 0xF7;
	        DisplayBuffer[7] &= NumberTab[gPlayContrl->CurFileIndex % 1000 / 100];
				  DisplayBuffer[6] |= 0xF7;
	        DisplayBuffer[6] &= NumberTab[gPlayContrl->CurFileIndex % 100  / 10];
				  DisplayBuffer[5] |= 0xF7;
	        DisplayBuffer[5] &= NumberTab[gPlayContrl->CurFileIndex % 10];
	        TimeOutSet(&PrevDispTimer, 2000);
}
/************************************************************************************/
static void DispAudioVol(void)        //œ‘“Ù¡ø
{
	        DisplayBuffer[8] |= 0xF7;
					DisplayBuffer[8] &= 0xED;    // ◊÷ƒ∏"U"
				  DisplayBuffer[7] |= 0xF7;
	        DisplayBuffer[7] &= 0xE8;     //◊÷ƒ∏°∞L°±
				  DisplayBuffer[6] |= 0xF7;
	        DisplayBuffer[6] &= NumberTab[(uint8_t)gSys.Volume  / 10];
				  DisplayBuffer[5] |= 0xF7;
	        DisplayBuffer[5] &= NumberTab[(uint8_t)gSys.Volume % 10];
	        TimeOutSet(&PrevDispTimer, 2000);
}
/************************************************************************************/
static void DispRtcTimer(void)        //œ‘ æ µ ± ±÷”–≈œ¢ø
{
	     //œ‘ æƒÍ–≈œ¢
	     if((GetRtcControlState() != RTC_STATE_IDLE) && (GetRtcControlSubState() == RTC_SET_YEAR)\
				   && (ColDispFlag == FALSE))
			 //µ±«∞’˝‘⁄…Ë÷√ƒÍ∑›£¨…¡À∏ƒÍ∑›±Í÷æ£ª“‘œ¬œ˚“˛
			 {
				  DisplayBuffer[12] |= 0xD7;
					DisplayBuffer[12] &= DISP_HIDDEN | 0x20;
					DisplayBuffer[11] |= 0xF7;
					DisplayBuffer[11] &= DISP_HIDDEN;
				  DisplayBuffer[10] |= 0xF7;
					DisplayBuffer[10] &= DISP_HIDDEN;
				  DisplayBuffer[9] |= 0xF7;
					DisplayBuffer[9] &= DISP_HIDDEN;
			 }
			 else
			 {
					DisplayBuffer[12] |= 0xD7;
					DisplayBuffer[12] &= NumberTab[sRtcControl->DataTime.Year / 1000] | 0x20;
					DisplayBuffer[11] |= 0xF7;
					DisplayBuffer[11] &= NumberTab[sRtcControl->DataTime.Year % 1000 / 100];
				  DisplayBuffer[10] |= 0xF7;
					DisplayBuffer[10] &= NumberTab[sRtcControl->DataTime.Year % 100 / 10];
				  DisplayBuffer[9] |= 0xF7;
					DisplayBuffer[9] &= NumberTab[sRtcControl->DataTime.Year % 10];
			 }
			  //œ‘ æ‘¬–≈œ¢
			 if((GetRtcControlState() != RTC_STATE_IDLE) && (GetRtcControlSubState() == RTC_SET_MON)\
				   && (ColDispFlag == FALSE))
			 //œ˚“˛‘¬∑›œ‘ æ
			 {
				  DISP_MONDEC_OFF();
				  DisplayBuffer[4] |= 0x0F;
					DisplayBuffer[4] &= ((DISP_HIDDEN >> 4) | 0xF0);
					DisplayBuffer[3] |= 0x70;
					DisplayBuffer[3] &= ((DISP_HIDDEN << 4) | 0x0F);
					DISP_MON_OFF();
			 }
			 else
			 //œ‘ æ‘¬–≈œ¢
			 {
				  if((sRtcControl->DataTime.Mon / 10) > 0)
					{
						DISP_MONDEC_ON();
					}
					else
					{
						DISP_MONDEC_OFF();
					}
					DisplayBuffer[4] |= 0x0F;
					DisplayBuffer[4] &= ((NumberTab[sRtcControl->DataTime.Mon % 10] >> 4) | 0xF0);
					DisplayBuffer[3] |= 0x70;
					DisplayBuffer[3] &= ((NumberTab[sRtcControl->DataTime.Mon % 10] << 4) | 0x0F);
					DISP_MON_ON();
			 }
			 //œ‘ æÃÏ–≈œ¢
			 if((GetRtcControlState() != RTC_STATE_IDLE) && (GetRtcControlSubState() == RTC_SET_DAY)\
				   && (ColDispFlag == FALSE))
			 //œ˚“˛ÃÏœ‘ æ–≈œ¢
			 {
				  DisplayBuffer[2] |= 0xF7;
					DisplayBuffer[2] &= DISP_HIDDEN;
					DisplayBuffer[1] |= 0xF7;
					DisplayBuffer[1] &= DISP_HIDDEN;
					DISP_DATE_OFF();
			 }
			 else
			 //œ‘ æÃÏ–≈œ¢
			 {
					DisplayBuffer[2] |= 0xF7;
					DisplayBuffer[2] &= ((sRtcControl->DataTime.Date / 10) == 0)? DISP_HIDDEN : (NumberTab[sRtcControl->DataTime.Date / 10]);
					DisplayBuffer[1] |= 0xF7;
					DisplayBuffer[1] &= NumberTab[sRtcControl->DataTime.Date % 10];
					DISP_DATE_ON();
			 }
			 //œ‘ æ–° ±–≈œ¢
			 if((GetRtcControlState() != RTC_STATE_IDLE) && (GetRtcControlSubState() == RTC_SET_HOUR)\
				   && (ColDispFlag == FALSE))
			 //œ˚“˛–° ±
			 {
					DisplayBuffer[8] &= DISP_HIDDEN;
	        DisplayBuffer[7] &= DISP_HIDDEN;
			 }
			 else
			 //œ‘ æ–° ±
			 {
					DisplayBuffer[8] |= 0xF7;
					DisplayBuffer[8] &= NumberTab[sRtcControl->DataTime.Hour / 10];
				  DisplayBuffer[7] |= 0xF7;
	        DisplayBuffer[7] &= NumberTab[sRtcControl->DataTime.Hour % 10];
			 }
			 //œ‘ æ∑÷÷”–≈œ¢
			 if((GetRtcControlState() != RTC_STATE_IDLE) && (GetRtcControlSubState() == RTC_SET_MIN)\
				   && (ColDispFlag == FALSE))
			 //œ˚“˛∑÷÷”
			 {
				  DisplayBuffer[6] &= DISP_HIDDEN;
	        DisplayBuffer[5] &= DISP_HIDDEN;
			 }
			 else
			 //œ‘ æ∑÷÷”
			 {
				  DisplayBuffer[6] |= 0xF7;
	        DisplayBuffer[6] &= NumberTab[sRtcControl->DataTime.Min / 10];
				  DisplayBuffer[5] |= 0xF7;
	        DisplayBuffer[5] &= NumberTab[sRtcControl->DataTime.Min % 10];
			 }
}
/************************************************************************************/
static void DisplayRadioFreq(void)   //œ‘ æFM∆µ¬ 
{
#ifdef FUNC_RADIO_EN
	        DISP_DOT_ON();                           //ø™–° ˝µ„                 
				  DISP_MHz_ON();                           //ø™∆µ¬ µ•Œªœ‘ æ       
	        DisplayBuffer[8] |= 0xF7;
	        DisplayBuffer[8] &= (sRadioControl->Freq / 1000 == 0)?DISP_HIDDEN : NumberTab[sRadioControl->Freq / 1000 ];
				  DisplayBuffer[7] |= 0xF7;
	        DisplayBuffer[7] &=  (sRadioControl->Freq / 100 == 0)?DISP_HIDDEN : NumberTab[sRadioControl->Freq % 1000 / 100];
				  DisplayBuffer[6] |= 0xF7;
	        DisplayBuffer[6] &=  (sRadioControl->Freq / 10 == 0)?DISP_HIDDEN : NumberTab[sRadioControl->Freq % 100  / 10];
				  DisplayBuffer[5] |= 0xF7;
	        DisplayBuffer[5] &= NumberTab[sRadioControl->Freq % 10];   
#endif	
}
/************************************************************************************/
static void DisplayRadioNumber(void)   //œ‘ æFMµÁÃ®ƒø¬º
{
#ifdef FUNC_RADIO_EN
	        DisplayBuffer[8] |= 0xF7;
	        DisplayBuffer[8] &= DISP_HIDDEN;   //œ˚“˛
				  DisplayBuffer[7] |= 0xF7;
	        DisplayBuffer[7] &=  0x7B;                   //◊÷ƒ∏°∞P°±
				  DisplayBuffer[6] |= 0xF7; 
	        DisplayBuffer[6] &=  NumberTab[((uint8_t)sRadioControl->CurStaIdx +1) / 10];
				  DisplayBuffer[5] |= 0xF7;
	        DisplayBuffer[5] &= NumberTab[((uint8_t)sRadioControl->CurStaIdx+1)  % 10]; 
          TimeOutSet(&PrevDispTimer, 1000);	
#endif
}
/************************************************************************************/
static void DisplayString(void)   //œ‘ æœ‡πÿƒ£ Ωœ¬µƒ◊÷∑˚¥Æ–≈œ¢
{
	        if(gSys.CurModuleID == MODULE_ID_BLUETOOTH)
					{
	            DisplayBuffer[8] |= 0xF7;
	            DisplayBuffer[8] &= 0xEE;                    //◊÷ƒ∏°∞b°±
				      DisplayBuffer[7] |= 0xF7;
	            DisplayBuffer[7] &=  0xE8;                   //◊÷ƒ∏°∞L°±
				      DisplayBuffer[6] |= 0xF7; 
	            DisplayBuffer[6] &=  0xED;                   //◊÷ƒ∏°∞U°±
				      DisplayBuffer[5] |= 0xF7;
	            DisplayBuffer[5] &= 0xFA;                    //◊÷ƒ∏°∞E°±
					}
					else if(gSys.CurModuleID == MODULE_ID_PLAYER_SD || gSys.CurModuleID == MODULE_ID_PLAYER_USB)
					{
						  DisplayBuffer[8] |= 0xF7;
	            DisplayBuffer[8] &= 0x7B;                    //◊÷ƒ∏°∞p°±
				      DisplayBuffer[7] |= 0xF7;
	            DisplayBuffer[7] &=  0x7F;                   //◊÷ƒ∏°∞A°±
				      DisplayBuffer[6] |= 0xF7; 
	            DisplayBuffer[6] &=  0xED;                   //◊÷ƒ∏°∞U°±
				      DisplayBuffer[5] |= 0xF7;
	            DisplayBuffer[5] &= 0xBE;                    //◊÷ƒ∏°∞S°±
					}
					else if(gSys.CurModuleID == MODULE_ID_LINEIN)
					{
						  DisplayBuffer[8] |= 0xF7;
	            DisplayBuffer[8] &= DISP_HIDDEN;    //œ˚“˛
				      DisplayBuffer[7] |= 0xF7;
	            DisplayBuffer[7] &=  0x7F;                   //◊÷ƒ∏°∞A°±
				      DisplayBuffer[6] |= 0xF7; 
	            DisplayBuffer[6] &=  0xED;                  //◊÷ƒ∏°∞U°±
				      DisplayBuffer[5] |= 0xF7;
	            DisplayBuffer[5] &= 0x6F;                    //◊÷ƒ∏°∞H°±
					}
}
/************************************************************************************/
static void  HT1621DisplaySet(void)
{
	   //œ‘ æÕ£¡Ùµƒ ±º‰µΩ¡À£¨ªÚ’ﬂµ±«∞’˝‘⁄œ‘ æµƒƒ⁄»›–Ë“™À¢–¬
	  if(IsTimeOut(&PrevDispTimer) || CurDisplayId == PrevDisplayId)
		{
			  DISP_RTCDATE_OFF();                                      //«Â≥˝»’∆⁄–≈œ¢
			  DISP_MAINFLAG_OFF();                                    //πÿ±’÷˜∆¡ƒªµƒ∆‰À˚Õº±Í
			  switch(CurDisplayId)
				{
					case  DISP_MODULE_PLAYTIMER:              //œ‘ æ≤•∑≈ ±º‰
						 DisplayTimer();
					   break;
					case  DISP_MODULE_SONGNUM:                //œ‘ æ∏Ë«˙«˙ƒø
						DispSongNumber();
					  break;
					case  DISP_MODULE_AUDIOVOL:                //œ‘ æ“Ù¡øº∂±–≈œ¢
						DispAudioVol();
					  break;
					case  DISP_MODULE_RTCTIMER:                //œ‘ æ µ ± ±÷”–≈œ¢
						DispRtcTimer();
						break;
					case  DISP_MODULE_RADIOFREQ:             //œ‘ æFM ’Ã®∆µ¬ 
						DisplayRadioFreq();
            break;	
          case  DISP_MODULE_RADIONUM:              //œ‘ æFMµÁÃ®ƒø¬º
						DisplayRadioNumber();
            break;					
          case  DISP_MODULE_WELCOME:               //œ‘ æª∂”≠–≈œ¢
						//DisplayWelcome();
            break;
          case  DISP_MODULE_STRING:                     //œ‘ æœ‡πÿƒ£ Ωœ¬µƒ◊÷∑˚¥Æ
						DisplayString();
            break;					
					default:
						break;
				}
				PrevDisplayId = CurDisplayId;
				CurDisplayId = DISP_MODULE_NONE;
		}
}
/*************************************************************************************/
void  HT1621UpdataDisplay(void)    //À¢–¬HT1621œ‘ æ∑
{
	    uint8_t  count = 0;
	    static bool DisplayState;
	    //’‚¿Ô≈–∂œ «∑Ò”–”––ßµƒ–≈œ¢–Ë“™œ‘ æ
	    if(CurDisplayId  !=  DISP_MODULE_NONE && CurDisplayId  !=  DISP_MODULE_WELCOME)
			{
				  DisplayModuleFlag();
	        HT1621DisplaySet();
			}
			//≈–∂œ «∑Ò–Ë“™œ‘ æ√ÎÕº±Í°£
		 if(IsTimeOut(&ColDispTimer) && IsTimeOut(&PrevDispTimer) && (gSys.CurModuleID == MODULE_ID_RTC))
		 {
			    //’‚¿Ô≤ª∂œ¥´ÀÕœ‘ æ µ ± ±÷”√¸¡Ó£¨ «Œ™¡À‘⁄…Ë÷√◊¥Ã¨ ±œ‡”¶…Ë÷√Œª…¡À∏£¨’‚¿Ôø…“‘»•µÙ
			    SendHt1621DispMsg(DISP_MODULE_RTCTIMER);
				  TimeOutSet(&ColDispTimer, 500);
				  ColDispFlag = !ColDispFlag;
				  if(ColDispFlag )
					{
						 DISP_COL_ON();
						//…Ë÷√ƒ÷÷”◊¥Ã¨£¨ƒ÷÷”Õº±Í…¡À∏
						 if(GetRtcControlState() == RTC_STATE_SET_ALARM)
						 {
							 DISP_ALARM_ON();
						 }
					}
					else
					{
						 DISP_COL_OFF();
						//…Ë÷√ƒ÷÷”◊¥Ã¨£¨ƒ÷÷”Õº±Í…¡À∏
						 if(GetRtcControlState() == RTC_STATE_SET_ALARM)
						 {
							 DISP_ALARM_OFF();
						 }
					}
			}
			//’‚¿Ô∑¿÷π–¥HT1621 ±≥ˆœ÷÷ÿ»ÎŒ Ã‚£¨ ±÷”ªÏ¬“∂¯Œﬁœ‘ æ
	    if(DisplayState == FALSE)                        
		  {
				  DisplayState = TRUE;
				  HT1621_CS_CLR();
	        Init_1621();
          Sendchar_h(0xa0,3);
          Sendchar_h(0x18,6);
          for (count = 0;count < 13 ;count++)
	        {
                Sendchar_l(DisplayBuffer[count],8);
          }
          HT1621_CS_SET();
				  DisplayState = FALSE;
			}
}

#endif
